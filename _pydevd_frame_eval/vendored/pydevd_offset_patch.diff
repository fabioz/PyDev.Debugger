This patch was applied to bytecode version 0.13.0 before calling
pydevd_fix_code.py to add an offset argument.

--- a/bytecode/concrete.py
+++ b/bytecode/concrete.py
@@ -41,14 +41,15 @@
     It has a read-only size attribute.
     """
 
-    __slots__ = ("_size", "_extended_args")
+    __slots__ = ("_size", "_extended_args", "offset")
 
-    def __init__(self, name, arg=UNSET, *, lineno=None, extended_args=None):
+    def __init__(self, name, arg=UNSET, *, lineno=None, extended_args=None, offset=None):
         # Allow to remember a potentially meaningless EXTENDED_ARG emitted by
         # Python to properly compute the size and avoid messing up the jump
         # targets
         self._extended_args = extended_args
         self._set(name, arg, lineno)
+        self.offset = offset
 
     def _check_arg(self, name, opcode, arg):
         if opcode >= _opcode.HAVE_ARGUMENT:
@@ -111,7 +112,10 @@
         else:
             arg = UNSET
         name = _opcode.opname[op]
-        return cls(name, arg, lineno=lineno)
+        # fabioz: added offset to ConcreteBytecode
+        # Need to keep an eye on https://github.com/MatthieuDartiailh/bytecode/issues/48 in
+        # case the library decides to add this in some other way.
+        return cls(name, arg, lineno=lineno, offset=index)
 
 
 class ConcreteBytecode(_bytecode._BaseBytecodeList):
@@ -376,6 +380,7 @@
                     arg,
                     lineno=instr.lineno,
                     extended_args=nb_extended_args,
+                    offset=instr.offset,
                 )
                 instructions[index] = instr
                 nb_extended_args = 0
@@ -491,7 +496,7 @@
                 arg = Compare(arg)
 
             if jump_target is None:
-                instr = Instr(instr.name, arg, lineno=lineno)
+                instr = Instr(instr.name, arg, lineno=lineno, offset=instr.offset)
             else:
                 instr_index = len(instructions)
             instructions.append(instr)
@@ -505,7 +510,7 @@
             instr = instructions[index]
             # FIXME: better error reporting on missing label
             label = labels[jump_target]
-            instructions[index] = Instr(instr.name, label, lineno=instr.lineno)
+            instructions[index] = Instr(instr.name, label, lineno=instr.lineno, offset=instr.offset)
 
         bytecode = _bytecode.Bytecode()
         bytecode._copy_attr_from(self)
--- a/bytecode/instr.py
+++ b/bytecode/instr.py
@@ -165,10 +165,11 @@
 class Instr:
     """Abstract instruction."""
 
-    __slots__ = ("_name", "_opcode", "_arg", "_lineno")
+    __slots__ = ("_name", "_opcode", "_arg", "_lineno", "offset")
 
-    def __init__(self, name, arg=UNSET, *, lineno=None):
+    def __init__(self, name, arg=UNSET, *, lineno=None, offset=None):
         self._set(name, arg, lineno)
+        self.offset = offset
 
     def _check_arg(self, name, opcode, arg):
         if name == "EXTENDED_ARG":
@@ -344,7 +345,7 @@
         )
 
     def copy(self):
-        return self.__class__(self._name, self._arg, lineno=self._lineno)
+        return self.__class__(self._name, self._arg, lineno=self._lineno, offset=self.offset)
 
     def __repr__(self):
         if self._arg is not UNSET:
